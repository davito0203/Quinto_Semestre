%%-------------------------------------------------------------------
%% Definiciónn del tipo de documento
%%-------------------------------------------------------------------
\documentclass[twocolumn]{IEEEtran}
%%-------------------------------------------------------------------
%% Paquetes y librerías que se van a cargar
%%-------------------------------------------------------------------
\usepackage{graphicx}%manejo de graficos
\usepackage[latin1]{}% Escritura en castellano con acentos
\usepackage{times}
\usepackage{amssymb,amsfonts}
\usepackage[tbtags]{amsmath}
\usepackage{cite}
\usepackage[all]{xy}
\usepackage[ansinew]{inputenc}
\usepackage{graphics,graphicx,color,colortbl}
\usepackage{times}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{multicol}
\usepackage{cite}
\usepackage{url}
\usepackage[tbtags]{amsmath}
\usepackage{amsmath,amssymb,amsfonts,amsbsy}
\usepackage{bm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[all]{xy}
\usepackage[centerlast, small]{caption}
\usepackage[colorlinks=true, citecolor=blue, linkcolor=blue, urlcolor=blue, breaklinks=true]{hyperref}
%\usepackage[dvips, pdfstartview=FitH, bookmarks=true,hypertexnames=false, letterpaper,linktocpage,colorlinks=true, citecolor=blue, linkcolor=blue, urlcolor=blue, breaklinks=true]{hyperref}
%%-------------------------------------------------------------------
%% Inicio del documento
%%-------------------------------------------------------------------
\begin{document}
%%-------------------------------------------------------------------
\title{Reloj Digital Con Alarma implementado en una FPGA}
%%-------------------------------------------------------------------
%% Autor y otros datos
%%-------------------------------------------------------------------
\author{David Ricardo Martínez Hernández Código: $261931$\\
        Juan Pablo Rodríguez Rojas Código: $261744$\\
        Camilo Andrés Garzón Código:}
\maketitle
%%-------------------------------------------------------------------
\markboth{Universidad Nacional de Colombia}{}
%%-------------------------------------------------------------------
%% Otras definciones en español
%%-------------------------------------------------------------------
\floatname{algorithm}{Algoritmo}
%%---------------------------------------------------------
%% Resumen y Palabras clave
%%--------------------------------------------------------
\begin{abstract}
El reloj con alarma que implementamos es un reloj que funciona con hora definida de $0$ minutos con $0$ horas hasta $23$ horas y $59$ minutos, es decir se denomina una hora militar. Al inicializar el reloj automáticamente se muestra la hora del reloj que por defecto será las $0$ horas con $0$ minutos, mientras no se modifique la hora esa será la hora a la que el reloj se encuentre programado, para modificar esta hora podemos observar la Fig.\ref{fig7} que corresponde a los controladores de la FPGA en la cual se esta presentando la aplicación. Para activar la modificación de la hora se activa el primer switch de derecha a izquierda, aquel que se denomina $SW0$, luego se podrá aumentar los minutos con el primer pulsador de izquierda a derecha ($BTN0$), y para las horas se hace con el pulsador que se encuentra enseguida ($BTN1$), así se realiza la modificación de la hora del reloj. Para modificar la alarma se debe desactivar el switch $SW0$, y se procede a activar el switch que se encuentra en la primera posición de izquierda a derecha es decir $SW7$, se puede observar cambia la visualización del los displays $7$ $-$ $segmentos$, observando la hora en la que se encuentra programada la alarma (por defecto se encuentra programada a las $0$ horas con $0$ minutos). Luego después de activar $SW7$, se puede modificar la alarma utilizando los mismos pulsadores que usaron para modificar la hora del reloj. Para terminar se desactiva $SW7$ y en el momento en que coinciden la hora de la alarma con la hora del reloj se puede observar como se prende el primer Led de izquierda a derecha ($LD7$)) (Fig. \ref{fig7}), lo que indica que se activo la señal de alarma esta podrá ser desactivada si se presiona el pulsador que  esta en la primera posición de derecha a izquierda ($BTN3$).
\end{abstract}

\begin{keywords}
Flanco de bajada, Flanco de subida, Flip-Flops, Frecuencia, Horas, Minutos, Registros, Segundos, Señal de reloj.
\end{keywords}
%%---------------------------------------------------------
%% Cuerpo del trabajo
%%---------------------------------------------------------
\section{Objetivos}
\begin{itemize}
  \item Utilizar las estrategias de comprensión de análisis de sistemas digitales aprendidas en la clase para solucionar un problema cotidiano.
  \item Aprender la correcta utilización de los lenguajes HDL para la implementación de los sistemas digitales.
  \item Manejar los dispositivos programables FPGA para poder implementar más recursivamente, y por supuesto con el fin de facilitar la implementación del proyecto.
  \item Analizar como los diferentes tipos de descripción secuencial o combinacional, pueden ser utilizados con el fin de describir distintas tareas.
\end{itemize}

\section{Introducción}
\noindent
Por un tiempo prolongado se programo en lenguajes como \textbf{FORTRAN}, \textbf{Pascal} y \textbf{C} en sus inicios se usaron  para la descripción de programas de computadoras haciendo de estos secuenciales por naturaleza.\\
\textbf{VHDL} viene de \textbf{VHSIC} (\textit{Very Speed Integrated Circuit}), VHDL es un lenguaje de descripción y modelado, diseñado para describir la funcionalidad y la organización de sistemas hardware digitales, placas de circuitos y componentes.\\
VHDL fue diseñado como en lenguaje para el modelado y simulación lógica de los sistemas digitales, además es un lenguaje con una sintaxis amplia y flexible permitiendo así el modelado estructural, teniendo como objetivo el desarrollo de un modelo para la \textbf{simulación} de un circuito. También permite el diseño Top-Down, permitiendo describir el comportamiento de los bloques de alto nivel, analizándolos y refinando la funcionalidad de alto nivel requerida antes de llegar a niveles más bajos de abstracción de la implementación del diseño\footnote{Texto tomada de \cite{page1}}.\\\\
Las \textbf{FPGA} (\textit{Field Programmable Gate Array}) (Fig.\ref{fig7}), introducidas por \textbf{Xilinx} en 1985, son el dispositivo programable por el usuario de más general espectro. También se denominan \textbf{LCA} (\textit{Logic Cell Array}). Consisten en una matriz bidimensional de bloques configurables que se pueden conectar mediante recursos generales de interconexión. Estos recursos incluyen segmentos de pista de diferentes longitudes, más unos conmutadores programables para enlazar bloques a pistas o pistas entre sí. En realidad, lo que se programa en una \textbf{FPGA} son los conmutadores que sirven para realizar las conexiones entre los diferentes bloques, más la configuración de los bloques.
\begin{figure}[H]
	\centering
		\includegraphics[scale=0.5]{Figuras/FPGA_Interruptores.png}
	\caption{Interruptores y Pulsadores FPGA Spartan3}
	\label{fig7}
\end{figure}
\noindent
Un \textit{\textbf{decodificador}} es un circuito lógico con variables de varias entradas y salidas que convierte las entradas codificadas en salidas codificadas, donde los códigos de entrada son diferentes, en donde el código de entrada tiene generalmente menos bits que el de salida.\footnote{Definición tomada de \cite{wakerly}, \textit{Pág 351}}\\
Un ejemplo muy común de aplicación de los contadores son los sistemas de control de tiempo, entre los cuales se encuentra \textbf{El Reloj Digital}. El cual presenta la hora en los displays distribuidos de la  siguiente manera (Fig. \ref{fig1}):
\begin{figure}[H]
	\centering
		\includegraphics[scale=0.4]{Figuras/formathm.png}
	\caption{Formato Hora \cite{floyd}, \tiny{\textit{Pág 594}}}
	\label{fig1}
\end{figure}
\noindent
Se genera un tren de impulsos a $1$ $Hz$ para tener el control de los segundos, esta señal de reloj actualizara los estados de los contadores. Este circuito se puede implementar por medio de Flip-Flops conectados sincrónicamente.\\
Los contadores cuentan desde $0$ hasta $59$ y lugo vuelve a $0$ para la etapa de \textit{minutos} y \textit{segundos}, para la etapa de \textit{horas} se implementa por medio del \textbf{Contador de Décadas} contando desde $1$ hasta $12$, o de $0$ hasta $23$ de acuerdo a la configuración del fabricante.\\


\section{Materiales y Métodos}
\noindent
Para realizar esta práctica se necesito:
\begin{itemize}
  \item Computador.
  \item FPGA.
  \item Software Xilinx, Inc.
\end{itemize}

\section{Análisis y Resultados}
\noindent
Debido a que se implemento el sistema utilizando una descripción de modularidad, es necesario iniciar con el modulo central del programa que será el encargado de unir los demás submodulos que se crearon, este tipo de organización de los módulos en principales o top, y secundarios o Down, se denomina un diseño top Down, el cual es el nombre técnico que se le asigna a este tipo de descripción de tareas.\\
Como lo mencionamos utilizamos un modulo central que es el siguiente (Fig. \ref{fig9}):\\
\begin{figure}[]
	\centering
		\includegraphics[scale=0.6]{Figuras/codigo.png}
	\caption{Código utilizado}
    \label{fig9}    
\end{figure}
\noindent
Como se puede apreciar en el anterior código se hace llamado a los demás módulos, además se observa que existen muchas variables de tipo wire, estas variables funcionan de manera que sirven para conectar los diferentes módulos. Es así que iniciaremos explicando cada uno de los submodulos y paralelamente explicaremos como utilizamos las salidas de estos submodulos en la entra de los demás submodulos y así podremos explicar el funcionamiento del proyecto realizado.\\
Como vemos en el modulo central se enuncian las variables utilizadas, primero las entradas, que en este caso son los comandos que se encuentran entre las líneas $28$ a $33$, y así se encuentran referenciadas todas las variables que se utilizaron para la implementación del presente proyecto.\\
Como vemos los dos primeros módulos que utilizamos se denominan $debouncer$ (nombre en ingles para anti-rebote), debido a que para modificar los minutos y las horas utilizamos pulsadores necesitamos crear un modulo de anti rebote para evitar este problema de los pulsadores, así que las salidas de este modulo son $dm$ y $dh$, que serán los nuevos impulsos pero que tendrán evitado dicho inconveniente.\\
Los siguientes módulos son freq1 y freq2, ambos son dos módulos que dividen la frecuencia del reloj interno de la FPGA que estamos utilizando que tiene una frecuencia de $50$ $MHz$, el primer modulo crea una señal de reloj que tiene un periodo de $1$ minuto, $fmin$, el cual ha de ser utilizado para modificar automáticamente la hora del reloj. Mientras que el segundo entrega una señal de reloj que tiene una frecuencia de $200$ $Hz$, $fmux$, que hemos de utilizarla para la visualización de la hora en los cuatro displays $7$ $-$ $segmentos$, proceso que explicaremos posteriormente.\\
El siguiente modulo que utilizamos se denomina $muxbotones$, que como su nombre insinúa se trata de un multiplexor, que debido  a que los botones que modifican manualmente la hora y los minutos del reloj y de la alarma son los mismos, se necesitaba un sistema que decidiera en el momento en que se pulsan dichos botones que le asignara el cambio a lo que se quiere modificar ya sea el reloj o la alarma, es así que por ende de este modulo  existen cuatro salidas, el estimulo de las horas del reloj, $hrel$, el de minutos del reloj, $mrel$, el impulso que genera las modificaciones de la alarma en cuanto a minutos, mala, y el que genera la modificación de las horas de la alarma, hala.\\
El siguiente modulo que utilizamos es el modulo $fsmalarm$, es el modulo que genera la modificación de la alarma, y como vemos genera cuatro salidas $h0$, $h1$, $h2$, $h3$, que son números de $4-bits$, deben de ser de ese tamaño puesto que para la parte de decodificación para generar el numero mas alto que tenemos que en este caso es $9$, se necesitan $4-bits$, donde $h0$, significa las unidades de minutos, como podemos apreciar en la declaración de las variables para este modulo líneas de $52$ a $55$.\\
El siguiente modulo que utilizamos es $fsmreloj$, el cual como en el caso anterior se encarga igualmente de modificar el reloj de la manera que describimos en el proceso de funcionamiento, igualmente como en el modulo anterior genera cuatro números de $4-bits$, que son los que se muestran en las líneas $57$ a $60$, pero este modulo además genera una señal cuadrada de un minuto llamada $ifreqmin$, la cual se explicara su funcionamiento en un modulo posterior.\\
El siguiente modulo es $muxnums$, como su nombre revela se trata de nuevo de un multiplexor, el cual cumple la función de escoger entre los números del reloj o los de la alarma, ya que en cuanto se modifica el switch que activa la opción de cambiar la hora del reloj, inmediatamente en la visualización aparece la hora de la alarma, por eso necesitamos escoger entre los números que se visualizaran, y por ende las salidas de este modulo son $j0$, $j1$, $j2$, $j3$, que están definidas en las líneas $62$ a  $65$.\\
Luego sigue el modulo sound, que es el encargado de comparar el valor de la hora del reloj con la de la alarma y generar un estimulo que será el Led en caso de que coincidan ambas horas, así como también esta encargado de controlar que cuando se desee apagar la alarma se pueda hacer, como vemos este modulo tiene como entradas los numero de la alarma, así como los números dl reloj, el botón off que funciona para desactivar la alarma , y la frecuencia de $ifreqmin$, que es una señal de 1 minuto de periodo que salía del modulo que modifica la hora del reloj.\\
La frecuencia de este modulo aunque es la misma que la señal de un minuto de periodo tiene cierto retraso ya que se activa apartir de la señal de un minuto de periodo inicial, y por ende permite que se comparen los números en este modulo inmediatamente apenas cambia, ya que de no ser así se activaría la alarma siempre un minuto después del momento en el cual debería activarse, esto funciona debido a que como los minutos cambian en el flanco de subida de la señal original de 1 minuto, entonces aunque sean iguales no seria si no hasta el siguiente flanco que el modulo anterior compararía y generaría la señal de alarma, por ende al hacer este cambio aunque seguimos trabajando con una señal de 1 minuto de periodo esta ocurre después de la original, por ende el flanco de subida será un tiempo posterior, pudiendo entonces comparar los números en el mismo instante en que cambian y así generar la señal de alarma en el momento adecuado.\\
El siguiente modulo que necesitamos es el modulo $muxvisual$, lo que genera este modulo es que debido a que tenemos que cada $7$ segmentos es un ánodo diferente, en el caso de que no se asigne un ánodo especifico, todos los $4-7$ $segmentos$ mostraran el mismo numero, por ende necesitamos que cada uno muestre un numero diferente la mayoría del tiempo, por ende realizamos la función de que fuera apagando $3$ ánodos cada vez y mostrando en el ánodo que queda encendido el numero deseado.\\
Por eso es que para que el ojo humano no detecte que se esta pagando y prendiendo ánodos, es que se hace esto a una frecuencia de $200$ $Hz$, la cual salía del modulo $freq2$, así es que realizamos el proceso que generara una visualización que el ojo detectara como si fueran todos ánodos diferentes, y por ende es que las entradas de este modulo son las que salían del modulo $muxnums$, descrito anteriormente, y como debemos ver un numero en cada $7$ segmentos por eso es que la salida de este modulo, aparte de los $4-7$ segmentos, es un numero denominado $numerofinal$, el cual es utilizado en la etapa del siguiente modulo.\\
Y para finalizar la descripción de los módulos y del funcionamiento del reloj, tenemos el modulo de visualización que consiste en un codificador binario $BCD$, que se utiliza para el $7$ segmentos de ahí que la salida sea un numero de 7-bits que es el necesario para hacer la decodificación, y así es como podemos ver un numero $BCD$ en los  segmentos.

\section{Conclusiones}
\begin{itemize}
  \item Se comprendió que la utilización de los lenguajes para describir hardware funcionan de manera paralela y no secuencia aunque el lenguaje es muy parecido a $C++$ el cual funciona de manera secuencial.
  \item El lenguaje $HDL$ o $VHDL$ es una herramienta muy útil para diseñar y modelar sistemas de hardware, placas de circuitos y componentes, aunque su principal función es realizar simulaciones muy precisas , también tiene la ventaja que se puede escribir muy similar a $C$, es decir posee un lenguaje de programación muy conocido y básico.
  \item El principal problema al realizar esta práctica fue pasar el $carri$ de salida, es decir cuando el reloj llegara a $59$ minutos tenia que hacer el cambio de hora (valor de la hora mas $1$) pero no lo realizaba, debido a que se encontraba una posición que lo llevaba a $00$ y no contaba ese $1$.
  \item Se realizaron muchas pruebas, lo primera que se realizo fue comprobando que estaba contando pero contaba de $0$ a $F$, luego se modifico el código (se encontraba como una maquina de estados) a un diseño muy parecido a $C$. Finalmente se realizaron las pruebas correspondientes pero no funcionaba el $carri$ de salida, al solucionar este problema se obtuvo lo que se esperaba.
\end{itemize}


%%---------------------------------------------------------
%% Bibliografía
%%---------------------------------------------------------
\bibliographystyle{ieeetran}
\begin{thebibliography}{99}

\bibitem{dorf} Dorf Svoboda.
{\em "`Circuitos Eléctricos"'}.
Alfaomega, 2006.

\bibitem{savant} C. J. Savant.
{\em "`Diseños Electrónicos: Circuitos de Sistema"'}.
Prentice-Hall, 2006.

\bibitem{wakerly} John F. Wakerly.
{\em "`Diseño Digital: Principios y Prácticas"'}.
Prentice-Hall, 2001.

\bibitem{floyd} Thomas L. Floyd.
{\em "`Fundamentos de Sistemas Digitales"'}.
Prentice-Hall, 2000.

\bibitem{page1} Sito Web: \url{http://www.jeuazarru.com/docs/VHDL.pdf}


\end{thebibliography}
%%---------------------------------------------------------
%% Fin del documento
%%---------------------------------------------------------
\end{document}
